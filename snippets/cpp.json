{
  "fenwick": {
    "prefix": "fenwick",
    "description": "Fenwick Tree",
    "body": [
      "template <typename T>",
      "struct Fenwick {",
      "    int n;",
      "    std::vector<T> a;",
      "",
      "    Fenwick(int n_ = 0) {",
      "        init(n_);",
      "    }",
      "",
      "    void init(int n_) {",
      "        n = n_;",
      "        a.assign(n, T{});",
      "    }",
      "",
      "    void add(int x, const T& v) {",
      "        for (int i = x + 1; i <= n; i += i & -i) {",
      "            a[i - 1] = a[i - 1] + v;",
      "        }",
      "    }",
      "",
      "    T sum(int x) {",
      "        T ans{};",
      "        for (int i = x; i > 0; i -= i & -i) {",
      "            ans = ans + a[i - 1];",
      "        }",
      "        return ans;",
      "    }",
      "",
      "    T rangeSum(int l, int r) {",
      "        return sum(r) - sum(l);",
      "    }",
      "};"
    ]
  },
  "Z": {
    "prefix": "Z",
    "description": "Automatically do modulo",
    "body": [
      "int norm(int x) {",
      "    if (x < 0) {",
      "        x += P;",
      "    }",
      "    if (x >= P) {",
      "        x -= P;",
      "    }",
      "    return x;",
      "}",
      "",
      "template<class T>",
      "T power(T a, i64 b) {",
      "    T res = 1;",
      "    for (; b; b /= 2, a *= a) {",
      "        if (b % 2) {",
      "            res *= a;",
      "        }",
      "    }",
      "    return res;",
      "}",
      "",
      "struct Z {",
      "    int x;",
      "    Z(int x = 0) : x(norm(x)) {}",
      "    Z(i64 x) : x(norm(x % P)) {}",
      "    int val() const {",
      "        return x;",
      "    }",
      "    Z operator-() const {",
      "        return Z(norm(P - x));",
      "    }",
      "    Z inv() const {",
      "        assert(x != 0);",
      "        return power(*this, P - 2);",
      "    }",
      "    Z &operator*=(const Z &rhs) {",
      "        x = i64(x) * rhs.x % P;",
      "        return *this;",
      "    }",
      "    Z &operator+=(const Z &rhs) {",
      "        x = norm(x + rhs.x);",
      "        return *this;",
      "    }",
      "    Z &operator-=(const Z &rhs) {",
      "        x = norm(x - rhs.x);",
      "        return *this;",
      "    }",
      "    Z &operator/=(const Z &rhs) {",
      "        return *this *= rhs.inv();",
      "    }",
      "    friend Z operator*(const Z &lhs, const Z &rhs) {",
      "        Z res = lhs;",
      "        res *= rhs;",
      "        return res;",
      "    }",
      "    friend Z operator+(const Z &lhs, const Z &rhs) {",
      "        Z res = lhs;",
      "        res += rhs;",
      "        return res;",
      "    }",
      "    friend Z operator-(const Z &lhs, const Z &rhs) {",
      "        Z res = lhs;",
      "        res -= rhs;",
      "        return res;",
      "    }",
      "    friend Z operator/(const Z &lhs, const Z &rhs) {",
      "        Z res = lhs;",
      "        res /= rhs;",
      "        return res;",
      "    }",
      "    friend std::istream &operator>>(std::istream &is, Z &a) {",
      "        i64 v;",
      "        is >> v;",
      "        a = Z(v);",
      "        return is;",
      "    }",
      "    friend std::ostream &operator<<(std::ostream &os, const Z &a) {",
      "        return os << a.val();",
      "    }",
      "};"
    ]
  },
  "Treap": {
    "prefix": "Treap",
    "description": "A portmanteau of tree and heap.",
    "body": [
      "struct item {",
      "\tint key, prior, cnt, size;",
      "\titem *l, *r;",
      "\titem () { }",
      "\titem (int key) : key(key), prior(std::rand()), l(nullptr), r(nullptr), cnt(1), size(1) { }",
      "};",
      "",
      "using pitem = item*;",
      "",
      "pitem root = nullptr;",
      "",
      "void update(pitem& x) {",
      "\tx->size = x->cnt + (x->l ? x->l->size : 0) + (x->r ? x->r->size : 0);",
      "}",
      "",
      "void zig(pitem& x) {",
      "\tpitem y = x->l;",
      "\tx->l = y->r, y->r = x, x = y;",
      "\tupdate(x), update(x->r);",
      "}",
      "",
      "void zag(pitem& x) {",
      "\tpitem y = x->r;",
      "\tx->r = y->l, y->l = x, x = y;",
      "\tupdate(x), update(x->l);",
      "}",
      "",
      "void insert(pitem& x, int y) {",
      "\tif (!x) ",
      "\t\treturn x = new item(y), void();",
      "\tif (x->key == y) ",
      "\t\treturn ++ x->cnt, update(x), void();",
      "\tif (y < x->key) {",
      "\t\tinsert(x->l, y);",
      "\t\tif (x->l->prior > x->prior) zig(x);",
      "\t} else {",
      "\t\tinsert(x->r, y);",
      "\t\tif (x->r->prior > x->prior) zag(x);",
      "\t}",
      "\tupdate(x);",
      "}",
      "",
      "void remove(pitem& x, int y) {",
      "\tif (y < x->key) remove(x->l, y);",
      "\telse if (y > x->key) remove(x->r, y);",
      "\telse {",
      "\t\tif (x->cnt > 1) -- x->cnt;",
      "\t\telse if (!x->l) x = x->r;",
      "\t\telse if (!x->r) x = x->l;",
      "\t\telse {",
      "\t\t\tzag(x);",
      "\t\t\tremove(x->l, y);",
      "\t\t\tif (x->l && x->l->prior > x->prior)",
      "\t\t\t\tzig(x);",
      "\t\t}",
      "\t}",
      "\tif (x) update(x);",
      "}",
      "",
      "pitem getPre(int v) {",
      "\tpitem x = root, ans = new item(-1e9);",
      "\twhile (x) {",
      "\t\tif (v == x->key) ",
      "\t\t\tif (x->l) {",
      "\t\t\t\tx = x->l;",
      "\t\t\t\twhile (x->r) x = x->r;",
      "\t\t\t\tans = x;",
      "\t\t\t}",
      "\t\tif (x->key < v && x->key > ans->key) ",
      "\t\t\tans = x;",
      "\t\tx = v < x->key ? x->l : x->r;",
      "\t}",
      "\treturn ans;",
      "}",
      "",
      "pitem getNxt(int v) {",
      "\tpitem x = root, ans = new item(1e9);",
      "\twhile (x) {",
      "\t\tif (v == x->key) ",
      "\t\t\tif (x->r) {",
      "\t\t\t\tx = x->r;",
      "\t\t\t\twhile (x->l) x = x->l;",
      "\t\t\t}",
      "\t\tif (x->key > v && x->key < ans->key)",
      "\t\t\tans = x;",
      "\t\tx = v > x->key ? x->r : x->l;",
      "\t}",
      "\treturn ans;",
      "}",
      "",
      "int getValByRank(pitem& x, int rank) {",
      "\tif (!x) return 1e9;",
      "\tif ((x->l ? x->l->size : 0) >= rank)",
      "\t\treturn getValByRank(x->l, rank);",
      "\tif ((x->l ? x->l->size : 0) + x->cnt >= rank) ",
      "\t\treturn x->key;",
      "\treturn getValByRank(x->r, rank - (x->l ? x->l->size : 0) - x->cnt);",
      "}",
      "",
      "int getRankByVal(pitem& x, int v) {",
      "\tif (!x) return 0;",
      "\tif (v == x->key) return (x->l ? x->l->size : 0) + 1;",
      "\tif (v < x->key) return getRankByVal(x->l, v);",
      "\treturn getRankByVal(x->r, v) + (x->l ? x->l->size : 0) + x->cnt;",
      "}"
    ]
  },
  "BigInt": {
    "prefix": "BigInt",
    "description": "Big integer",
    "body": [
      "constexpr i64 BASE = 1e8, WEIGHT = 8;",
      "",
      "struct BigInt {",
      "    std::vector<i64> num;",
      "    BigInt() {}",
      "    BigInt(const char* x) {",
      "        i64 len = strlen(x), t = 0;",
      "        for (i64 i = 0, w = 1; i < len; w *= 10, i++) {",
      "            if (w == BASE) {",
      "                num.push_back(t);",
      "                w = 1, t = 0;",
      "            }",
      "            t += w * (x[len - i - 1] - 48);",
      "        }",
      "        if (t) {",
      "            num.push_back(t);",
      "        }",
      "    }",
      "    BigInt(const i64 x) {",
      "        char tmp[100];",
      "        sprintf(tmp, \"%lld\", x);",
      "        *this = tmp;",
      "    }",
      "    BigInt(const int x) {",
      "        *this = static_cast<i64>(x);",
      "    }",
      "    friend std::ostream& operator<<(std::ostream& os, const BigInt x) {",
      "        if (x.num.empty()) {",
      "            os << 0;",
      "        }",
      "        for (int i = x.num.size() - 1; i >= 0; i--) {",
      "            if (i != x.num.size() - 1) {",
      "                os << std::setfill('0') << std::setw(WEIGHT) << x.num[i];",
      "            } else {",
      "                os << x.num[i];",
      "            }",
      "        }",
      "        return os;",
      "    }",
      "    friend std::istream& operator>>(std::istream& is, BigInt& x) {",
      "        std::string str;",
      "        is >> str;",
      "        x = str.c_str();",
      "        return is;",
      "    }",
      "    template <typename T>",
      "    BigInt operator+(const T rst) {",
      "        BigInt res, x = rst;",
      "        i64 t = 0;",
      "        for (int i = 0; i < num.size() || i < x.num.size(); i++) {",
      "            if (i < num.size()) {",
      "                t += num[i];",
      "            }",
      "            if (i < x.num.size()) {",
      "                t += x.num[i];",
      "            }",
      "            res.num.push_back(t % BASE);",
      "            t /= BASE;",
      "        }",
      "        while (t) {",
      "            res.num.push_back(t % BASE);",
      "            t /= BASE;",
      "        }",
      "        while (res.num.size() > 1 && res.num.back() == 0) {",
      "            res.num.pop_back();",
      "        }",
      "        return res;",
      "    }",
      "    BigInt operator*(const i64 rst) {",
      "        BigInt res, x = rst;",
      "        i64 t = 0;",
      "        for (auto& x : num) {",
      "            t += x * rst;",
      "            res.num.push_back(t % BASE);",
      "            t /= BASE;",
      "        }",
      "        while (t) {",
      "            res.num.push_back(t % BASE);",
      "            t /= BASE;",
      "        }",
      "        while (res.num.size() > 1 && res.num.back() == 0) {",
      "            res.num.pop_back();",
      "        }",
      "        return res;",
      "    }",
      "    template <typename T>",
      "    BigInt operator*(const T rst) {",
      "        BigInt res = 0, x = rst;",
      "        std::reverse(x.num.begin(), x.num.end());",
      "        for (auto& i : x.num) {",
      "            res = res * BASE + *this * i;",
      "        }",
      "        return res;",
      "    }",
      "    BigInt operator/(const i64 rst) {",
      "        BigInt res;",
      "        i64 t = 0;",
      "        for (int i = num.size() - 1; i >= 0; i--) {",
      "            t = t * BASE + num[i];",
      "            res.num.push_back(t / rst);",
      "            t %= rst;",
      "        }",
      "        std::reverse(res.num.begin(), res.num.end());",
      "        while (res.num.size() > 1 && res.num.back() == 0) {",
      "            res.num.pop_back();",
      "        }",
      "        return res;",
      "    }",
      "    template <typename T>",
      "    BigInt& operator*=(const T rst) {",
      "        *this = *this * rst;",
      "        return *this;",
      "    }",
      "    template <typename T>",
      "    BigInt& operator+=(const T rst) {",
      "        *this = *this + rst;",
      "        return *this;",
      "    }",
      "    template <typename T>",
      "    auto operator<=>(T rst) {",
      "        BigInt x = rst;",
      "        if (num.size() != x.num.size()) {",
      "            return num.size() <=> x.num.size();",
      "        } else {",
      "            for (int i = num.size() - 1; i >= 0; i--) {",
      "                if (num[i] != x.num[i]) {",
      "                    return num[i] <=> x.num[i];",
      "                }",
      "            }",
      "        }",
      "        return std::strong_ordering::equal;",
      "    }",
      "};"
    ]
  },
  "exgcd": {
    "prefix": "exgcd",
    "description": "\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5",
    "body": [
      "i64 exgcd(i64 a, i64 b, i64 &x, i64 &y) {",
      "    if (b == 0) { ",
      "\t\tx = 1, y = 0;",
      "\t\treturn a; ",
      "\t}",
      "    i64 d = exgcd(b, a % b, y, x);",
      "    y -= x * (a / b);",
      "    return d;",
      "}"
    ]
  },
  "IO": {
    "prefix": "IO",
    "description": "\u5feb\u8bfb/\u5feb\u8f93",
    "body": [
      "namespace IO {",
      "char buf[1 << 23], *p1 = buf, *p2 = buf;",
      "#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)",
      "template <typename T>",
      "inline T read() {",
      "    char c = getchar();",
      "    T res = 0, sig = 1;",
      "    while (!std::isdigit(c)) {",
      "        if (c == '-') {",
      "            sig = -1;",
      "        }",
      "        c = getchar();",
      "    }",
      "    while (std::isdigit(c)) {",
      "        res = res * 10 + c - '0'; ",
      "        c = getchar();",
      "    }",
      "    return res * sig;",
      "}",
      "template <typename T>",
      "inline void write(T x) {",
      "    if (!x) {",
      "        putchar('0'); ",
      "        return;",
      "    }",
      "    static int stk[100], tail = 0;",
      "    if (x < 0) {",
      "        x = -x; ",
      "        putchar('-');",
      "    }",
      "    while (x) {",
      "        stk[tail++] = x % 10; ",
      "        x /= 10;",
      "    }",
      "    for (int i = --tail; i >= 0; i--) {",
      "        putchar(stk[i] + '0');",
      "    }",
      "}",
      "template <typename T>",
      "inline void read(T& x) {",
      "    x = read<T>();",
      "}",
      "template <typename T, typename... Args>",
      "inline void read(T& x, Args&... args) {",
      "    read(x); ",
      "    read(args...);",
      "}",
      "struct reader {",
      "    template <typename T>",
      "    reader& operator>>(T& x) {",
      "        if constexpr (std::is_integral_v<T> && !std::is_same_v<std::decay_t<T>, char>) {",
      "            read(x);",
      "        } else {",
      "            std::cout << x;",
      "        }",
      "        return *this;",
      "    }",
      "} cin;",
      "struct writer {",
      "    template <typename T>",
      "    writer& operator<<(T x) {",
      "        if constexpr (std::is_integral_v<T> && !std::is_same_v<std::decay_t<T>, char>) {",
      "            write(x);",
      "        } else {",
      "            std::cout << x;",
      "        }",
      "        return *this;",
      "    }",
      "} cout;",
      "};"
    ]
  },
  "Seg": {
    "prefix": "Seg",
    "description": "\u533a\u95f4\u6700\u5927\u503c\u7ebf\u6bb5\u6811",
    "body": [
      "struct Info {",
      "    int max = 0;",
      "};",
      "",
      "Info operator+(const Info& a, const Info& b) {",
      "    return { std::max(a.max, b.max) };",
      "}",
      "",
      "template <typename Info>",
      "struct SegmentTree {",
      "    int n;",
      "    std::vector<int> tag;",
      "    std::vector<Info> info;",
      "",
      "    SegmentTree(int n_) : n(n_), tag(n * 4), info(n * 4) {}",
      "",
      "    void pull(int p) {",
      "        info[p] = info[p * 2] + info[p * 2 + 1];",
      "    }",
      "",
      "    void add(int p, int v) {",
      "        tag[p] = std::max(tag[p], v);",
      "        info[p].max = std::max(info[p].max, v);",
      "    }",
      "",
      "    void push(int p) {",
      "        add(2 * p, tag[p]);",
      "        add(2 * p + 1, tag[p]);",
      "        tag[p] = 0;",
      "    }",
      "",
      "    Info query(int p, int l, int r, int x, int y) {",
      "        if (l >= y || r <= x) {",
      "            return {};",
      "        }",
      "        if (l >= x && r <= y) {",
      "            return info[p];",
      "        }",
      "        int mid = (l + r) / 2;",
      "        push(p);",
      "        return query(p * 2, l, mid, x, y) + query(p * 2 + 1, mid, r, x, y);",
      "    }",
      "",
      "    Info query(int x, int y) {",
      "        return query(1, 0, n, x, y);",
      "    }",
      "",
      "    void rangeAdd(int p, int l, int r, int x, int y, int v) {",
      "        if (l >= y || r <= x) {",
      "            return;",
      "        }",
      "        if (l >= x && r <= y) {",
      "            add(p, v);",
      "            return;",
      "        }",
      "        int mid = (l + r) / 2;",
      "        push(p);",
      "        rangeAdd(p * 2, l, mid, x, y, v);",
      "        rangeAdd(p * 2 + 1, mid, r, x, y, v);",
      "        pull(p);",
      "    }",
      "",
      "    void rangeAdd(int x, int y, int v) {",
      "        rangeAdd(1, 0, n, x, y, v);",
      "    }",
      "",
      "    void modify(int p, int l, int r, int x, const Info& v) {",
      "        if (r - l == 1) {",
      "            info[p] = v;",
      "            return;",
      "        }",
      "        int mid = (l + r) / 2;",
      "        push(p);",
      "        if (x < mid) {",
      "            modify(p * 2, l, mid, x, v); ",
      "        } else {",
      "            modify(p * 2 + 1, mid, r, x, v);",
      "        }",
      "        pull(p);",
      "    }",
      "",
      "    void modify(int x, const Info& v) {",
      "        modify(1, 0, n, x, v);",
      "    }",
      "};"
    ]
  },
  "qpow": {
    "prefix": "qpow",
    "description": "Fast power",
    "body": [
      "i64 qpow(i64 a, i64 b) {",
      "    i64 res = 1;",
      "    for (; b; b >>= 1) {",
      "\t\tif (b & 1) res *= a;",
      "\t\ta *= a;",
      "    }",
      "    return res;",
      "}"
    ]
  },
  "geometry": {
    "prefix": "geometry",
    "description": "Geometry template",
    "body": [
      "namespace Geometry {",
      "using ld = long double;",
      "ld pi = acos(-1);",
      "ld eps = 1e-8;",
      "int sgn(ld x) { return (x > eps) - (x < -eps); }",
      "ld norm(ld x) { return sgn(x) ? x : 0; }",
      "ld toRad(ld d) { return d * pi / 180; }",
      "struct Line;",
      "// Point",
      "struct Vector {",
      "    ld x, y;",
      "    Vector(ld x_ = 0, ld y_ = 0) : x(x_), y(y_) {}",
      "    Vector operator-() const { return Vector(-x, -y); }",
      "    friend Vector operator+(Vector a, Vector b) { return Vector(a.x + b.x, a.y + b.y); }",
      "    friend Vector operator-(Vector a, Vector b) { return Vector(a.x - b.x, a.y - b.y); }",
      "    friend Vector operator*(Vector a, ld b) { return Vector(a.x * b, a.y * b); }",
      "    friend Vector operator*(ld a, Vector b) { return Vector(a * b.x, a * b.y); }",
      "    friend Vector operator/(Vector a, ld b) { return Vector(a.x / b, a.y / b); }",
      "    friend bool operator==(Vector a, Vector b) { return !sgn(a.x - b.x) && !sgn(a.y - b.y); }",
      "    friend ld operator*(Vector a, Vector b) { return a.x * b.x + a.y * b.y; } // \u70b9\u4e58",
      "    friend ld operator^(Vector a, Vector b) { return a.x * b.y - a.y * b.x; } // \u53c9\u4e58",
      "    Vector unitVec() { return *this / len(); }",
      "    ld len() { return sqrt(*this * *this); }  // \u6b27\u51e0\u91cc\u5f97\u8ddd\u79bb",
      "    ld len2() { return *this * *this; }       // \u6b27\u51e0\u91cc\u5f97\u8ddd\u79bb(\u4e0d\u5f00\u65b9)",
      "    ld lenM() { return abs(x) + abs(y); }     // \u66fc\u54c8\u987f\u8ddd\u79bb",
      "    Vector rotate() { return Vector(-y, x); } // \u9006\u65f6\u9488\u65cb\u8f6c90",
      "    Vector rotate(ld rad) {                   // \u9006\u65f6\u9488\u65cb\u8f6crad",
      "        return Vector(x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad));",
      "    }",
      "    int direction() { // [0,pi)->1, [pi,2*pi)->-1",
      "        return y > 0 || (sgn(y) == 0 && x > 0) ? 1 : -1;",
      "    }",
      "    friend istream &operator>>(istream &is, Vector &p) { return is >> p.x >> p.y; }",
      "    friend ostream &operator<<(ostream &os, Vector &p) {",
      "        return os << \"(\" << norm(p.x) << \", \" << norm(p.y) << \")\";",
      "    }",
      "    // \u70b9\u4e0e\u76f4\u7ebf",
      "    int PointLineRelation(Line l); // 0: on, 1: left, -1: right",
      "    bool onSegment(Line l);",
      "    ld PointLineDist(Line l);",
      "    Vector PointLineProj(Line l);",
      "};",
      "// Vector",
      "ld angle1(Vector a, Vector b) { return acos(a * b / a.len() / b.len()); } // \u5939\u89d2",
      "ld angle2(Vector a, Vector b) { return abs(atan2(abs(a ^ b), a * b)); }   // \u5939\u89d2",
      "bool parallel(Vector a, Vector b) { return sgn(a ^ b) == 0; }             // \u5e73\u884c",
      "bool vertical(Vector a, Vector b) { return sgn(a * b) == 0; }             // \u5782\u76f4",
      "// Line",
      "struct Line {",
      "    Vector a, b;",
      "    Line(Vector a_ = Vector(), Vector b_ = Vector()) : a(a_), b(b_) {}",
      "    friend ostream &operator<<(ostream &os, Line l) {",
      "        return os << \"<\" << l.a << \", \" << l.b << \">\";",
      "    }",
      "};",
      "using Segment = Line;",
      "int Vector::PointLineRelation(Line l) { return sgn((l.b - l.a) ^ (*this - l.a)); }",
      "bool Vector::onSegment(Line l) {",
      "    return sgn((l.b - l.a) ^ (*this - l.a)) == 0 && sgn((l.a - *this) * (l.b - *this)) <= 0;",
      "}",
      "ld Vector::PointLineDist(Line l) { return abs((l.b - l.a) ^ (*this - l.a)) / (l.b - l.a).len(); }",
      "Vector Vector::PointLineProj(Line l) {",
      "    return l.a + (l.b - l.a) * ((*this - l.a) * (l.b - l.a)) / (l.b - l.a).len2();",
      "}",
      "int LineRelation(Line l1, Line l2) { // 0: \u5e73\u884c 1: \u91cd\u5408 2: \u76f8\u4ea4",
      "    if (sgn((l2.b - l2.a) ^ (l1.b - l1.a)))",
      "        return (l1.a.PointLineRelation(l2) == 0) ? 1 : 0;",
      "    return 2;",
      "}",
      "}; // namespace Geometry"
    ]
  },
  "debug": {
    "prefix": "debug",
    "description": "grandfather dir",
    "body": [
      "#ifndef ONLINE_JUDGE",
      "#include \"../../.debug.cpp\"",
      "#endif"
    ]
  },
  "pii": {
    "prefix": "pii",
    "description": "pair<int, int>",
    "body": [
      "std::pair<int, int>$0"
    ]
  },
  "adj": {
    "prefix": "adj",
    "description": "adj list",
    "body": [
      "std::vector<std::vector<int>> adj(n);"
    ]
  },
  "binary_search": {
    "prefix": "binary_search",
    "description": "binary search",
    "body": [
      "*std::ranges::partition_point(std::ranges::iota_view($1, $2), $3)$0"
    ]
  },
  "DSU": {
    "prefix": "DSU",
    "description": "dsu",
    "body": [
      "struct DSU {",
      "    std::vector<int> f, siz;",
      "    ",
      "    DSU() {}",
      "    DSU(int n) {",
      "        init(n);",
      "    }",
      "    ",
      "    void init(int n) {",
      "        f.resize(n);",
      "        std::iota(f.begin(), f.end(), 0);",
      "        siz.assign(n, 1);",
      "    }",
      "    ",
      "    int find(int x) {",
      "        while (x != f[x]) {",
      "            x = f[x] = f[f[x]];",
      "        }",
      "        return x;",
      "    }",
      "    ",
      "    bool same(int x, int y) {",
      "        return find(x) == find(y);",
      "    }",
      "    ",
      "    bool merge(int x, int y) {",
      "        x = find(x);",
      "        y = find(y);",
      "        if (x == y) {",
      "            return false;",
      "        }",
      "        siz[x] += siz[y];",
      "        f[y] = x;",
      "        return true;",
      "    }",
      "    ",
      "    int size(int x) {",
      "        return siz[find(x)];",
      "    }",
      "};"
    ]
  },
  "SCC": {
    "prefix": "SCC",
    "description": "Strongly connected components",
    "body": [
      "struct SCC {",
      "    int n;",
      "    std::vector<std::vector<int>> adj;",
      "    std::vector<int> dfn, low, bel;",
      "    std::vector<int> stk;",
      "    int cur, cnt;",
      "",
      "    SCC() {}",
      "    SCC(int n) {",
      "        init(n);",
      "    }",
      "",
      "    void init(int n) {",
      "        this->n = n;",
      "        adj.assign(n, {});",
      "        dfn.assign(n, -1);",
      "        low.resize(n);",
      "        bel.assign(n, -1);",
      "        stk.clear();",
      "        cur = cnt = 0;",
      "    }",
      "",
      "    void addEdge(int u, int v) {",
      "        adj[u].push_back(v);",
      "    }",
      "",
      "    void dfs(int u) {",
      "        dfn[u] = low[u] = cur ++;",
      "        stk.push_back(u);",
      "        ",
      "        for (auto v : adj[u]) {",
      "            if (dfn[v] == -1) {",
      "                dfs(v);",
      "                low[u] = std::min(low[u], low[v]);",
      "            } else if (bel[v] == -1) {",
      "                low[u] = std::min(low[u], dfn[v]);",
      "            }",
      "        }",
      "        ",
      "        if (dfn[u] == low[u]) {",
      "            int v;",
      "            do {",
      "                v = stk.back();",
      "                bel[v] = cnt;",
      "                stk.pop_back();",
      "            } while (v != u);",
      "            cnt ++;",
      "        }",
      "    }",
      "",
      "    std::vector<int> work() {",
      "        for (int i = 0; i < n; i ++) {",
      "            if (dfn[i] == -1) {",
      "                dfs(i);",
      "            }",
      "        }",
      "        return bel;",
      "    }",
      "};"
    ]
  },
  "RMQ": {
    "prefix": "RMQ",
    "description": "range max/min query",
    "body": [
      "template <class T, class Cmp = std::less<T>>",
      "struct RMQ {",
      "    const Cmp cmp = Cmp(); ",
      "    int n;",
      "    std::vector<std::vector<T>> a;",
      "",
      "    RMQ() {}",
      "    RMQ(const std::vector<T> &v) {",
      "        init(v);",
      "    }",
      "",
      "    void init(const std::vector<T> &v) {",
      "        n = v.size();",
      "        if (!n) {",
      "            return;",
      "        }",
      "",
      "        const int lg = std::__lg(n);",
      "        a.assign(lg + 1, std::vector<T>(n));",
      "",
      "        for (int i = 0; i < n; i ++) {",
      "            a[0][i] = v[i];",
      "        }",
      "",
      "        for (int j = 0; j < lg; j ++) {",
      "            for (int i = 0; i + (1 << j) < n; i ++) {",
      "                a[j + 1][i] = std::min(a[j][i], a[j][i + (1 << j)], cmp);",
      "            } ",
      "        }",
      "    }",
      "",
      "    T operator()(int l, int r) {",
      "        assert(l <= r);",
      "        int lg = std::__lg(r - l);",
      "        T ans = std::min(a[lg][l], a[lg][r - (1 << lg)], cmp);",
      "        return ans;",
      "    }",
      "};"
    ]
  },
  "sieve": {
    "prefix": "sieve",
    "description": "Euler Sieve",
    "body": [
      "std::vector<int> minp, primes;",
      "",
      "void sieve(int n) {",
      "    minp.assign(n + 1, 0);",
      "    primes.clear();",
      "    ",
      "    for (int i = 2; i <= n; i++) {",
      "        if (minp[i] == 0) {",
      "            minp[i] = i;",
      "            primes.push_back(i);",
      "        }",
      "        ",
      "        for (auto p : primes) {",
      "            if (i * p > n) {",
      "                break;",
      "            }",
      "            minp[i * p] = p;",
      "            if (p == minp[i]) {",
      "                break;",
      "            }",
      "        }",
      "    }",
      "}",
      "",
      "bool isprime(int n) {",
      "    return minp[n] == n;",
      "}"
    ]
  },
  "rng": {
    "prefix": "rng",
    "description": "random",
    "body": [
      "std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());"
    ]
  }
}
