{
	"fenwick": {
		"prefix": "fenwick",
		"description": "Fenwick Tree",
		"body": [
			"template <typename T>",
			"struct Fenwick {",
			"    int n;",
			"    std::vector<T> a;",
			"",
			"    Fenwick(int n_ = 0) {",
			"        init(n_);",
			"    }",
			"",
			"    void init(int n_) {",
			"        n = n_;",
			"        a.assign(n, T{});",
			"    }",
			"",
			"    void add(int x, const T& v) {",
			"        for (int i = x + 1; i <= n; i += i & -i) {",
			"            a[i - 1] = a[i - 1] + v;",
			"        }",
			"    }",
			"",
			"    T sum(int x) {",
			"        T ans{};",
			"        for (int i = x; i > 0; i -= i & -i) {",
			"            ans = ans + a[i - 1];",
			"        }",
			"        return ans;",
			"    }",
			"",
			"    T rangeSum(int l, int r) {",
			"        return sum(r) - sum(l);",
			"    }",
			"};"
		]
	},
	"Z": {
		"prefix": "Z",
		"description": "Automatically do modulo",
		"body": [
			"int norm(int x) {",
			"    if (x < 0) {",
			"        x += P;",
			"    }",
			"    if (x >= P) {",
			"        x -= P;",
			"    }",
			"    return x;",
			"}",
			"",
			"template<class T>",
			"T power(T a, i64 b) {",
			"    T res = 1;",
			"    for (; b; b /= 2, a *= a) {",
			"        if (b % 2) {",
			"            res *= a;",
			"        }",
			"    }",
			"    return res;",
			"}",
			"",
			"struct Z {",
			"    int x;",
			"    Z(int x = 0) : x(norm(x)) {}",
			"    Z(i64 x) : x(norm(x % P)) {}",
			"    int val() const {",
			"        return x;",
			"    }",
			"    Z operator-() const {",
			"        return Z(norm(P - x));",
			"    }",
			"    Z inv() const {",
			"        assert(x != 0);",
			"        return power(*this, P - 2);",
			"    }",
			"    Z &operator*=(const Z &rhs) {",
			"        x = i64(x) * rhs.x % P;",
			"        return *this;",
			"    }",
			"    Z &operator+=(const Z &rhs) {",
			"        x = norm(x + rhs.x);",
			"        return *this;",
			"    }",
			"    Z &operator-=(const Z &rhs) {",
			"        x = norm(x - rhs.x);",
			"        return *this;",
			"    }",
			"    Z &operator/=(const Z &rhs) {",
			"        return *this *= rhs.inv();",
			"    }",
			"    friend Z operator*(const Z &lhs, const Z &rhs) {",
			"        Z res = lhs;",
			"        res *= rhs;",
			"        return res;",
			"    }",
			"    friend Z operator+(const Z &lhs, const Z &rhs) {",
			"        Z res = lhs;",
			"        res += rhs;",
			"        return res;",
			"    }",
			"    friend Z operator-(const Z &lhs, const Z &rhs) {",
			"        Z res = lhs;",
			"        res -= rhs;",
			"        return res;",
			"    }",
			"    friend Z operator/(const Z &lhs, const Z &rhs) {",
			"        Z res = lhs;",
			"        res /= rhs;",
			"        return res;",
			"    }",
			"    friend std::istream &operator>>(std::istream &is, Z &a) {",
			"        i64 v;",
			"        is >> v;",
			"        a = Z(v);",
			"        return is;",
			"    }",
			"    friend std::ostream &operator<<(std::ostream &os, const Z &a) {",
			"        return os << a.val();",
			"    }",
			"};"
		]
	},
	"Treap": {
		"prefix": "Treap",
		"description": "A portmanteau of tree and heap.",
		"body": [
			"constexpr int inf = 1e7 + 10;",
			"std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());",
			"",
			"struct Node {",
			"    Node *l, *r;",
			"    int cnt, siz, val, pri;",
			"",
			"    Node () {}",
			"    Node (int v) {",
			"        init(v);",
			"    }",
			"",
			"    void init(int v) {",
			"        l = nullptr;",
			"        r = nullptr;",
			"        cnt = 1;",
			"        siz = 1;",
			"        val = v;",
			"        pri = rng();",
			"    }",
			"",
			"    int size() {",
			"        siz = cnt;",
			"        if (l) {",
			"            siz += l->siz;",
			"        }",
			"        if (r) {",
			"            siz += r->siz;",
			"        }",
			"        return siz;",
			"    }",
			"};",
			"",
			"class Treap {",
			"private:",
			"    Node* root;",
			"",
			"    void split(Node* t, int k, Node*& l, Node*& r) {",
			"        if (!t) {",
			"            l = nullptr;",
			"            r = nullptr;",
			"            return;",
			"        }",
			"",
			"        if (t->val <= k) {",
			"            l = t;",
			"            split(t->r, k, t->r, r);",
			"        } else {",
			"            r = t;",
			"            split(t->l, k, l, t->l);",
			"        }",
			"        t->size();",
			"    }",
			"",
			"    Node* merge(Node* l, Node* r) {",
			"        if (!l) return r;",
			"        if (!r) return l;",
			"",
			"        if (l->pri > r->pri) {",
			"            l->r = merge(l->r, r);",
			"            l->size();",
			"            return l;",
			"        } else {",
			"            r->l = merge(l, r->l);",
			"            r->size();",
			"            return r;",
			"        }",
			"    }",
			"",
			"    void _insert(Node*& t, int x) {",
			"        Node *l, *r, *m;",
			"        split(t, x, l, r);",
			"        split(l, x - 1, l, m);",
			"",
			"        if (m) {",
			"            m->cnt++;",
			"            m->size();",
			"        } else {",
			"            m = new Node(x);",
			"        }",
			"",
			"        t = merge(l, m);",
			"        t = merge(t, r);",
			"    }",
			"",
			"    void _del(Node*& t, int x) {",
			"        if (!t) return;",
			"",
			"        if (t->val == x) {",
			"            if (t->cnt > 1) {",
			"                t->cnt--;",
			"                t->size();",
			"            } else {",
			"                t = merge(t->l, t->r);",
			"            }",
			"        } else if (x < t->val) {",
			"            _del(t->l, x);",
			"            t->size();",
			"        } else {",
			"            _del(t->r, x);",
			"            t->size();",
			"        }",
			"    }",
			"",
			"    int _rank(Node* t, int x) {",
			"        if (!t) return 1;",
			"",
			"        if (x < t->val) {",
			"            return _rank(t->l, x);",
			"        } else if (x == t->val) {",
			"            return (t->l ? t->l->siz : 0) + 1;",
			"        } else {",
			"            return (t->l ? t->l->siz : 0) + t->cnt + _rank(t->r, x);",
			"        }",
			"    }",
			"",
			"    int _kth(Node* t, int k) {",
			"        if (!t) return -1;",
			"",
			"        int ls = t->l ? t->l->siz : 0;",
			"        if (k <= ls) {",
			"            return _kth(t->l, k);",
			"        } else if (k <= ls + t->cnt) {",
			"            return t->val;",
			"        } else {",
			"            return _kth(t->r, k - ls - t->cnt);",
			"        }",
			"    }",
			"",
			"    int _prev(Node* t, int x) {",
			"        if (!t) return -inf;",
			"",
			"        if (t->val >= x) {",
			"            return _prev(t->l, x);",
			"        } else {",
			"            int p = _prev(t->r, x);",
			"            return p > t->val ? p : t->val;",
			"        }",
			"    }",
			"",
			"    int _next(Node* t, int x) {",
			"        if (!t) return inf;",
			"",
			"        if (t->val <= x) {",
			"            return _next(t->r, x);",
			"        } else {",
			"            int n = _next(t->l, x);",
			"            return n < t->val ? n : t->val;",
			"        }",
			"    }",
			"",
			"public:",
			"    Treap() : root(nullptr) {}",
			"",
			"    void insert(int x) {",
			"        _insert(root, x);",
			"    }",
			"",
			"    void del(int x) {",
			"        _del(root, x);",
			"    }",
			"",
			"    int rank(int x) {",
			"        return _rank(root, x);",
			"    }",
			"",
			"    int kth(int k) {",
			"        return _kth(root, k);",
			"    }",
			"",
			"    int prev(int x) {",
			"        return _prev(root, x);",
			"    }",
			"",
			"    int next(int x) {",
			"        return _next(root, x);",
			"    }",
			"};"
		]
	},
	"BigInt": {
		"prefix": "BigInt",
		"description": "Big integer",
		"body": [
			"constexpr i64 BASE = 1e8, WEIGHT = 8;",
			"",
			"struct BigInt {",
			"    std::vector<i64> num;",
			"    BigInt() {}",
			"    BigInt(const char* x) {",
			"        i64 len = strlen(x), t = 0;",
			"        for (i64 i = 0, w = 1; i < len; w *= 10, i++) {",
			"            if (w == BASE) {",
			"                num.push_back(t);",
			"                w = 1, t = 0;",
			"            }",
			"            t += w * (x[len - i - 1] - 48);",
			"        }",
			"        if (t) {",
			"            num.push_back(t);",
			"        }",
			"    }",
			"    BigInt(const i64 x) {",
			"        char tmp[100];",
			"        sprintf(tmp, \"%lld\", x);",
			"        *this = tmp;",
			"    }",
			"    BigInt(const int x) {",
			"        *this = static_cast<i64>(x);",
			"    }",
			"    friend std::ostream& operator<<(std::ostream& os, const BigInt x) {",
			"        if (x.num.empty()) {",
			"            os << 0;",
			"        }",
			"        for (int i = x.num.size() - 1; i >= 0; i--) {",
			"            if (i != x.num.size() - 1) {",
			"                os << std::setfill('0') << std::setw(WEIGHT) << x.num[i];",
			"            } else {",
			"                os << x.num[i];",
			"            }",
			"        }",
			"        return os;",
			"    }",
			"    friend std::istream& operator>>(std::istream& is, BigInt& x) {",
			"        std::string str;",
			"        is >> str;",
			"        x = str.c_str();",
			"        return is;",
			"    }",
			"    template <typename T>",
			"    BigInt operator+(const T rst) {",
			"        BigInt res, x = rst;",
			"        i64 t = 0;",
			"        for (int i = 0; i < num.size() || i < x.num.size(); i++) {",
			"            if (i < num.size()) {",
			"                t += num[i];",
			"            }",
			"            if (i < x.num.size()) {",
			"                t += x.num[i];",
			"            }",
			"            res.num.push_back(t % BASE);",
			"            t /= BASE;",
			"        }",
			"        while (t) {",
			"            res.num.push_back(t % BASE);",
			"            t /= BASE;",
			"        }",
			"        while (res.num.size() > 1 && res.num.back() == 0) {",
			"            res.num.pop_back();",
			"        }",
			"        return res;",
			"    }",
			"    BigInt operator*(const i64 rst) {",
			"        BigInt res, x = rst;",
			"        i64 t = 0;",
			"        for (auto& x : num) {",
			"            t += x * rst;",
			"            res.num.push_back(t % BASE);",
			"            t /= BASE;",
			"        }",
			"        while (t) {",
			"            res.num.push_back(t % BASE);",
			"            t /= BASE;",
			"        }",
			"        while (res.num.size() > 1 && res.num.back() == 0) {",
			"            res.num.pop_back();",
			"        }",
			"        return res;",
			"    }",
			"    template <typename T>",
			"    BigInt operator*(const T rst) {",
			"        BigInt res = 0, x = rst;",
			"        std::reverse(x.num.begin(), x.num.end());",
			"        for (auto& i : x.num) {",
			"            res = res * BASE + *this * i;",
			"        }",
			"        return res;",
			"    }",
			"    BigInt operator/(const i64 rst) {",
			"        BigInt res;",
			"        i64 t = 0;",
			"        for (int i = num.size() - 1; i >= 0; i--) {",
			"            t = t * BASE + num[i];",
			"            res.num.push_back(t / rst);",
			"            t %= rst;",
			"        }",
			"        std::reverse(res.num.begin(), res.num.end());",
			"        while (res.num.size() > 1 && res.num.back() == 0) {",
			"            res.num.pop_back();",
			"        }",
			"        return res;",
			"    }",
			"    template <typename T>",
			"    BigInt& operator*=(const T rst) {",
			"        *this = *this * rst;",
			"        return *this;",
			"    }",
			"    template <typename T>",
			"    BigInt& operator+=(const T rst) {",
			"        *this = *this + rst;",
			"        return *this;",
			"    }",
			"    template <typename T>",
			"    auto operator<=>(T rst) {",
			"        BigInt x = rst;",
			"        if (num.size() != x.num.size()) {",
			"            return num.size() <=> x.num.size();",
			"        } else {",
			"            for (int i = num.size() - 1; i >= 0; i--) {",
			"                if (num[i] != x.num[i]) {",
			"                    return num[i] <=> x.num[i];",
			"                }",
			"            }",
			"        }",
			"        return std::strong_ordering::equal;",
			"    }",
			"};"
		]
	},
	"exgcd": {
		"prefix": "exgcd",
		"description": "Extended Euclidean algorithm",
		"body": [
			"i64 exgcd(i64 a, i64 b, i64 &x, i64 &y) {",
			"    if (b == 0) { ",
			"        x = 1, y = 0;",
			"        return a; ",
			"    }",
			"    i64 d = exgcd(b, a % b, y, x);",
			"    y -= x * (a / b);",
			"    return d;",
			"}"
		]
	},
	"IO": {
		"prefix": "IO",
		"description": "Fast read/write",
		"body": [
			"namespace IO {",
			"char buf[1 << 23], *p1 = buf, *p2 = buf;",
			"#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)",
			"template <typename T>",
			"inline T read() {",
			"    char c = getchar();",
			"    T res = 0, sig = 1;",
			"    while (!std::isdigit(c)) {",
			"        if (c == '-') {",
			"            sig = -1;",
			"        }",
			"        c = getchar();",
			"    }",
			"    while (std::isdigit(c)) {",
			"        res = res * 10 + c - '0'; ",
			"        c = getchar();",
			"    }",
			"    return res * sig;",
			"}",
			"template <typename T>",
			"inline void write(T x) {",
			"    if (!x) {",
			"        putchar('0'); ",
			"        return;",
			"    }",
			"    static int stk[100], tail = 0;",
			"    if (x < 0) {",
			"        x = -x; ",
			"        putchar('-');",
			"    }",
			"    while (x) {",
			"        stk[tail++] = x % 10; ",
			"        x /= 10;",
			"    }",
			"    for (int i = --tail; i >= 0; i--) {",
			"        putchar(stk[i] + '0');",
			"    }",
			"}",
			"template <typename T>",
			"inline void read(T& x) {",
			"    x = read<T>();",
			"}",
			"template <typename T, typename... Args>",
			"inline void read(T& x, Args&... args) {",
			"    read(x); ",
			"    read(args...);",
			"}",
			"struct reader {",
			"    template <typename T>",
			"    reader& operator>>(T& x) {",
			"        if constexpr (std::is_integral_v<T> && !std::is_same_v<std::decay_t<T>, char>) {",
			"            read(x);",
			"        } else {",
			"            std::cout << x;",
			"        }",
			"        return *this;",
			"    }",
			"} cin;",
			"struct writer {",
			"    template <typename T>",
			"    writer& operator<<(T x) {",
			"        if constexpr (std::is_integral_v<T> && !std::is_same_v<std::decay_t<T>, char>) {",
			"            write(x);",
			"        } else {",
			"            std::cout << x;",
			"        }",
			"        return *this;",
			"    }",
			"} cout;",
			"};"
		]
	},
	"Seg": {
		"prefix": "LazySegmentTree",
		"description": "Lazy segment tree",
		"body": [
			"struct Info {",
			"    int max = 0;",
			"};",
			"",
			"Info operator+(const Info& a, const Info& b) {",
			"    return { std::max(a.max, b.max) };",
			"}",
			"",
			"template <typename Info>",
			"struct SegmentTree {",
			"    int n;",
			"    std::vector<int> tag;",
			"    std::vector<Info> info;",
			"",
			"    SegmentTree(int n_) : n(n_), tag(n * 4), info(n * 4) {}",
			"",
			"    void pull(int p) {",
			"        info[p] = info[p * 2] + info[p * 2 + 1];",
			"    }",
			"",
			"    void add(int p, int v) {",
			"        tag[p] = std::max(tag[p], v);",
			"        info[p].max = std::max(info[p].max, v);",
			"    }",
			"",
			"    void push(int p) {",
			"        add(2 * p, tag[p]);",
			"        add(2 * p + 1, tag[p]);",
			"        tag[p] = 0;",
			"    }",
			"",
			"    Info query(int p, int l, int r, int x, int y) {",
			"        if (l >= y || r <= x) {",
			"            return {};",
			"        }",
			"        if (l >= x && r <= y) {",
			"            return info[p];",
			"        }",
			"        int mid = (l + r) / 2;",
			"        push(p);",
			"        return query(p * 2, l, mid, x, y) + query(p * 2 + 1, mid, r, x, y);",
			"    }",
			"",
			"    Info query(int x, int y) {",
			"        return query(1, 0, n, x, y);",
			"    }",
			"",
			"    void rangeAdd(int p, int l, int r, int x, int y, int v) {",
			"        if (l >= y || r <= x) {",
			"            return;",
			"        }",
			"        if (l >= x && r <= y) {",
			"            add(p, v);",
			"            return;",
			"        }",
			"        int mid = (l + r) / 2;",
			"        push(p);",
			"        rangeAdd(p * 2, l, mid, x, y, v);",
			"        rangeAdd(p * 2 + 1, mid, r, x, y, v);",
			"        pull(p);",
			"    }",
			"",
			"    void rangeAdd(int x, int y, int v) {",
			"        rangeAdd(1, 0, n, x, y, v);",
			"    }",
			"",
			"    void modify(int p, int l, int r, int x, const Info& v) {",
			"        if (r - l == 1) {",
			"            info[p] = v;",
			"            return;",
			"        }",
			"        int mid = (l + r) / 2;",
			"        push(p);",
			"        if (x < mid) {",
			"            modify(p * 2, l, mid, x, v); ",
			"        } else {",
			"            modify(p * 2 + 1, mid, r, x, v);",
			"        }",
			"        pull(p);",
			"    }",
			"",
			"    void modify(int x, const Info& v) {",
			"        modify(1, 0, n, x, v);",
			"    }",
			"};"
		]
	},
	"qpow": {
		"prefix": "qpow",
		"description": "Fast power",
		"body": [
			"int qpow(int a, int b) {",
			"    int res = 1;",
			"    for (; b; b /= 2, a = a * a) {",
			"        if (b % 2) {",
			"            res = res * a;",
			"        }",
			"    }",
			"    return res;",
			"}"
		]
	},
	"debug": {
		"prefix": "debug",
		"description": "debug header",
		"body": [
			"#ifndef ONLINE_JUDGE",
			"#include \".debug.cpp\"",
			"#endif"
		]
	},
	"binary_search": {
		"prefix": "binary_search",
		"description": "binary search",
		"body": [
			"*std::ranges::partition_point(std::ranges::iota_view($1, $2), $3)$0"
		]
	},
	"DSU": {
		"prefix": "DSU",
		"description": "dsu",
		"body": [
			"struct DSU {",
			"    std::vector<int> f, siz;",
			"    ",
			"    DSU() {}",
			"    DSU(int n) {",
			"        init(n);",
			"    }",
			"    ",
			"    void init(int n) {",
			"        f.resize(n);",
			"        std::iota(f.begin(), f.end(), 0);",
			"        siz.assign(n, 1);",
			"    }",
			"    ",
			"    int find(int x) {",
			"        while (x != f[x]) {",
			"            x = f[x] = f[f[x]];",
			"        }",
			"        return x;",
			"    }",
			"    ",
			"    bool same(int x, int y) {",
			"        return find(x) == find(y);",
			"    }",
			"    ",
			"    bool merge(int x, int y) {",
			"        x = find(x);",
			"        y = find(y);",
			"        if (x == y) {",
			"            return false;",
			"        }",
			"        siz[x] += siz[y];",
			"        f[y] = x;",
			"        return true;",
			"    }",
			"    ",
			"    int size(int x) {",
			"        return siz[find(x)];",
			"    }",
			"};"
		]
	},
	"SCC": {
		"prefix": "SCC",
		"description": "Strongly connected components",
		"body": [
			"struct SCC {",
			"    int n;",
			"    std::vector<std::vector<int>> adj;",
			"    std::vector<int> dfn, low, bel;",
			"    std::vector<int> stk;",
			"    int cur, cnt;",
			"",
			"    SCC() {}",
			"    SCC(int n) {",
			"        init(n);",
			"    }",
			"",
			"    void init(int n) {",
			"        this->n = n;",
			"        adj.assign(n, {});",
			"        dfn.assign(n, -1);",
			"        low.resize(n);",
			"        bel.assign(n, -1);",
			"        stk.clear();",
			"        cur = cnt = 0;",
			"    }",
			"",
			"    void addEdge(int u, int v) {",
			"        adj[u].push_back(v);",
			"    }",
			"",
			"    void dfs(int u) {",
			"        dfn[u] = low[u] = cur ++;",
			"        stk.push_back(u);",
			"        ",
			"        for (auto v : adj[u]) {",
			"            if (dfn[v] == -1) {",
			"                dfs(v);",
			"                low[u] = std::min(low[u], low[v]);",
			"            } else if (bel[v] == -1) {",
			"                low[u] = std::min(low[u], dfn[v]);",
			"            }",
			"        }",
			"        ",
			"        if (dfn[u] == low[u]) {",
			"            int v;",
			"            do {",
			"                v = stk.back();",
			"                bel[v] = cnt;",
			"                stk.pop_back();",
			"            } while (v != u);",
			"            cnt ++;",
			"        }",
			"    }",
			"",
			"    std::vector<int> work() {",
			"        for (int i = 0; i < n; i ++) {",
			"            if (dfn[i] == -1) {",
			"                dfs(i);",
			"            }",
			"        }",
			"        return bel;",
			"    }",
			"};"
		]
	},
	"RMQ": {
		"prefix": "RMQ",
		"description": "range max/min query",
		"body": [
			"template <class T, class Cmp = std::less<T>>",
			"struct RMQ {",
			"    const Cmp cmp = Cmp(); ",
			"    std::vector<std::vector<T>> st;",
			"",
			"    RMQ() {}",
			"    RMQ(const std::vector<T> &v) {",
			"        init(v);",
			"    }",
			"",
			"    void init(const std::vector<T> &v) {",
			"        int n = v.size();",
			"        int k = std::__lg(n);",
			"",
			"        st.assign(k + 1, std::vector<T>(n));",
			"        st[0] = v;",
			"",
			"        for (int j = 0; j < k; j++) {",
			"            for (int i = 0; i + (1 << j) < n; i++) {",
			"                st[j + 1][i] = std::min(st[j][i], st[j][i + (1 << j)], cmp);",
			"            } ",
			"        }",
			"    }",
			"",
			"    T operator()(int l, int r) {",
			"        int k = std::__lg(r - l);",
			"        T ans = std::min(st[k][l], st[k][r - (1 << k)], cmp);",
			"        return ans;",
			"    }",
			"};"
		]
	},
	"sieve": {
		"prefix": "sieve",
		"description": "Euler Sieve",
		"body": [
			"std::vector<int> minp, primes;",
			"",
			"void sieve(int n) {",
			"    minp.assign(n + 1, 0);",
			"    primes.clear();",
			"    ",
			"    for (int i = 2; i <= n; i++) {",
			"        if (minp[i] == 0) {",
			"            minp[i] = i;",
			"            primes.push_back(i);",
			"        }",
			"        ",
			"        for (auto p : primes) {",
			"            if (i * p > n) {",
			"                break;",
			"            }",
			"            minp[i * p] = p;",
			"            if (p == minp[i]) {",
			"                break;",
			"            }",
			"        }",
			"    }",
			"",
			"bool isprime(int n) {",
			"    return minp[n] == n;",
			"}"
		]
	},
	"rng": {
		"prefix": "rng",
		"description": "random",
		"body": [
			"std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());"
		]
	},
	"cartesian": {
				"prefix": "cartesian",
				"description": "Cartesian Tree",
				"body": [
						"struct Node {",
						"    Node *l = nullptr;",
						"    Node *r = nullptr;",
						"    int idx, val, par;",
						"",
						"    Node (int idx = 0, int val = 0, int par = 0) : idx(idx), val(val), par(par) {}",
						"    Node (const std::vector<int> &a) {",
						"        idx = 0; ",
						"        val = 0;",
						"        init(a);",
						"    }",
						"",
						"    void init(const std::vector<int> &a) {",
						"        std::vector<Node*> stk;",
						"        stk.push_back(this);",
						"",
						"        for (int i = 0; i < a.size(); i++) {",
						"            Node *cur = new Node(i, a[i]);",
						"            Node *lst = nullptr;",
						"",
						"            while (!stk.empty() && stk.back()->val > cur->val) {",
						"                lst = stk.back();",
						"                stk.pop_back();",
						"            }",
						"",
						"            if (!stk.empty()) {",
						"                stk.back()->r = cur;",
						"                cur->par = stk.back()->idx;",
						"            }",
						"",
						"            if (lst) {",
						"                cur->l = lst;",
						"                lst->par = cur->idx;",
						"            }",
						"",
						"            stk.push_back(cur);",
						"        }",
						"    }",
						"};"
				]
		},
	"PST": {
		"prefix": "PST",
		"description": "持久化线段树",
		"body": [
			"struct Node {",
			"    int cnt = 1;",
			"    Node* l = nullptr;",
			"    Node* r = nullptr;",
			"",
			"    Node() {}",
			"",
			"    Node(Node* t) {",
			"        if (t) {",
			"            cnt = t->cnt;",
			"            l = t->l;",
			"            r = t->r;",
			"        }",
			"    }",
			"};",
			"",
			"struct PersistentSegmentTree {",
			"    int n;",
			"    std::vector<Node*> p;",
			"",
			"    PersistentSegmentTree(int n_) : n(n_) {",
			"        p.push_back(build(0, n));",
			"    }",
			"",
			"    Node* build(int l, int r) {",
			"        Node* t = new Node();",
			"        if (l == r - 1) {",
			"            return t;",
			"        }",
			"",
			"        int mid = (l + r) / 2;",
			"        t->l = build(l, mid);",
			"        t->r = build(mid, r);",
			"        return t;",
			"    }",
			"",
			"    void insert(int pos) {",
			"        p.push_back(insert(p.back(), 0, n, pos));",
			"    }",
			"",
			"    Node* insert(Node* pre, int l, int r, int pos) {",
			"        Node* cur = new Node(pre);",
			"        cur->cnt++;",
			"",
			"        if (l == r - 1) {",
			"            return cur;",
			"        }",
			"",
			"        int mid = (l + r) / 2;",
			"        if (pos < mid) {",
			"            cur->l = insert(pre->l, l, mid, pos);",
			"        } else {",
			"            cur->r = insert(pre->r, mid, r, pos);",
			"        }",
			"",
			"        return cur;",
			"    }",
			"",
			"    int queryKth(int l, int r, int k) {",
			"        Node* L = p[l];",
			"        Node* R = p[r];",
			"",
			"        return queryKth(L, R, 0, n, k);",
			"    }",
			"",
			"    int queryKth(Node* L, Node* R, int l, int r, int k) {",
			"        if (l == r - 1) {",
			"            return l;",
			"        }",
			"",
			"        int mid = (l + r) / 2;",
			"        int cnt = R->l->cnt - L->l->cnt;",
			"",
			"        if (k <= cnt) {",
			"            return queryKth(L->l, R->l, l, mid, k);",
			"        } else {",
			"            return queryKth(L->r, R->r, mid, r, k - cnt);",
			"        }",
			"    }",
			"};"
		]
	},
	"binom": {
		"prefix": "binom",
		"description": "组合数计算与快速幂",
		"body": [
			"constexpr int P = 1000000007;",
			"constexpr int L = 200000;",
			"",
			"int fac[L + 1], invfac[L + 1];",
			"",
			"void init_binom() {",
			"    fac[0] = 1;",
			"    for (int i = 1; i <= L; i++) {",
			"        fac[i] = 1LL * fac[i - 1] * i % P;",
			"    }",
			"    invfac[L] = power(fac[L], P - 2);",
			"    for (int i = L; i; i--) {",
			"        invfac[i - 1] = 1LL * invfac[i] * i % P;",
			"    }",
			"}",
			"",
			"int binom(int n, int m) {",
			"    if (n < m || m < 0) {",
			"        return 0;",
			"    }",
			"    return 1LL * fac[n] * invfac[m] % P * invfac[n - m] % P;",
			"}",
			"",
			"int power(int a, int b) {",
			"    int res = 1;",
			"    for (; b; b /= 2, a = 1LL * a * a % P) {",
			"        if (b % 2) {",
			"            res = 1LL * res * a % P;",
			"        }",
			"    }",
			"    return res;",
			"}"
		]
	},
	"KMP": {
		"prefix": "KMP",
		"description": "KMP 字符串匹配算法",
		"body": [
			"std::vector<int> KMP(const std::string &s) {",
			"    int n = s.size();",
			"    std::vector<int> f(n + 1);",
			"    for (int i = 1, j = 0; i < n; i++) {",
			"        while (j && s[i] != s[j]) {",
			"            j = f[j];",
			"        }",
			"        j += (s[i] == s[j]);",
			"        f[i + 1] = j;",
			"    }",
			"    return f;",
			"}"
		]
	},
    "manacher": {
        "prefix": "manacher",
        "description": "manacher 算法",
        "body": [
            "std::vector<int> manacher(std::string s) {",
            "    std::string t = \"#\";",
            "    for (auto c : s) {",
            "        t += c;",
            "        t += '#';",
            "    }",
            "    int n = t.size();",
            "    std::vector<int> r(n);",
            "    for (int i = 0, j = 0; i < n; i++) {",
            "        if (2 * j - i >= 0 && j + r[j] > i) {",
            "            r[i] = std::min(r[2 * j - i], j + r[j] - i);",
            "        }",
            "        while (i - r[i] >= 0 && i + r[i] < n && t[i - r[i]] == t[i + r[i]]) {",
            "            r[i] += 1;",
            "        }",
            "        if (i + r[i] > j + r[j]) {",
            "            j = i;",
            "        }",
            "    }",
            "    return r;",
            "}"
        ]
    },
	"SegmentTree": {
		"prefix": "SegmentTree",
		"description": "Segment tree without lazy propagation",
		"body": [
			"template <typename Info>",
			"struct SegmentTree {",
			"    int n;",
			"    std::vector<Info> info;",
			"",
			"    SegmentTree(int n_) : n(n_), info(n * 4) {}",
			"",
			"    void build(int p, int l, int r, const auto& v) {",
			"        if (r - l == 1) {",
			"            info[p] = { v[l] % P };",
			"            return;",
			"        }",
			"        int mid = (l + r) / 2;",
			"        build(p * 2, l, mid, v);",
			"        build(p * 2 + 1, mid, r, v);",
			"        pull(p);",
			"    }",
			"",
			"    void build(const auto& v) {",
			"        build(1, 0, n, v);",
			"    }",
			"",
			"    void pull(int p) {",
			"        info[p] = info[p * 2] + info[p * 2 + 1];",
			"    }",
			"",
			"    Info query(int p, int l, int r, int x, int y) {",
			"        if (l >= y || r <= x) {",
			"            return {};",
			"        }",
			"        if (l >= x && r <= y) {",
			"            return info[p];",
			"        }",
			"        int mid = (l + r) / 2;",
			"        return query(p * 2, l, mid, x, y) + query(p * 2 + 1, mid, r, x, y);",
			"    }",
			"",
			"    Info query(int x, int y) {",
			"        return query(1, 0, n, x, y);",
			"    }",
			"",
			"    void modify(int p, int l, int r, int x, const Info& v) {",
			"        if (r - l == 1) {",
			"            info[p] = v;",
			"            return;",
			"        }",
			"        int mid = (l + r) / 2;",
			"        if (x < mid) {",
			"            modify(p * 2, l, mid, x, v); ",
			"        } else {",
			"            modify(p * 2 + 1, mid, r, x, v);",
			"        }",
			"        pull(p);",
			"    }",
			"",
			"    void modify(int x, const Info& v) {",
			"        modify(1, 0, n, x, v);",
			"    }",
			"};"
		]
	},
	"SA": {
		"prefix": "SA",
		"description": "后缀数组",
		"body": [
			"struct SA {",
			"    int n;",
			"    std::vector<int> sa, rk, lc;",
			"",
			"    SA(std::string s) {",
			"        n = s.size();",
			"        sa.resize(n);",
			"        lc.resize(n - 1);",
			"        rk.resize(n);",
			"        std::iota(sa.begin(), sa.end(), 0);",
			"        std::sort(sa.begin(), sa.end(),",
			"            [&](int a, int b) {",
			"                return s[a] < s[b];",
			"            });",
			"        rk[sa[0]] = 0;",
			"        for (int i = 1; i < n; i++) {",
			"            rk[sa[i]] = rk[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]);",
			"        }",
			"        int k = 1;",
			"        std::vector<int> tmp, cnt(n);",
			"        tmp.reserve(n);",
			"        while (rk[sa[n - 1]] < n - 1) {",
			"            tmp.clear();",
			"            for (int i = 0; i < k; i++) {",
			"                tmp.push_back(n - k + i);",
			"            }",
			"            for (auto i : sa) {",
			"                if (i >= k) {",
			"                    tmp.push_back(i - k);",
			"                }",
			"            }",
			"            std::fill(cnt.begin(), cnt.end(), 0);",
			"            for (int i = 0; i < n; i++) {",
			"                cnt[rk[i]]++;",
			"            }",
			"            for (int i = 1; i < n; i++) {",
			"                cnt[i] += cnt[i - 1];",
			"            }",
			"            for (int i = n - 1; i >= 0; i--) {",
			"                sa[--cnt[rk[tmp[i]]]] = tmp[i];",
			"            }",
			"            std::swap(rk, tmp);",
			"            rk[sa[0]] = 0;",
			"            for (int i = 1; i < n; i++) {",
			"                rk[sa[i]] = rk[sa[i - 1]] + (tmp[sa[i - 1]] < tmp[sa[i]] || sa[i - 1] + k == n || tmp[sa[i - 1] + k] < tmp[sa[i] + k]);",
			"            }",
			"            k *= 2;",
			"        }",
			"        for (int i = 0, j = 0; i < n; i++) {",
			"            if (rk[i] == 0) {",
			"                j = 0;",
			"            } else {",
			"                for (j -= j > 0; i + j < n && sa[rk[i] - 1] + j < n && s[i + j] == s[sa[rk[i] - 1] + j]; ) {",
			"                    j++;",
			"                }",
			"                lc[rk[i] - 1] = j;",
			"            }",
			"        }",
			"    }",
			"};"
		]
	},
	"Hash": {
		"prefix": "Hash",
		"description": "自定义哈希函数",
		"body": [
			"struct Hash {",
			"    static u64 splitmix64(u64 x) {",
			"        // http://xorshift.di.unimi.it/splitmix64.c",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			"",
			"    std::size_t operator()(u64 x) const {",
			"        static const u64 FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
			"        return splitmix64(x + FIXED_RANDOM);",
			"    }",
			"};"
		]
	},
	"ConvexHull": {
		"prefix": "ConvexHull",
		"description": "静态凸包",
		"body": [
			"struct Point {",
			"    i64 x;",
			"    i64 y;",
			"    Point() : x{0}, y{0} {}",
			"    Point(i64 x_, i64 y_) : x{x_}, y{y_} {}",
			"};",
			"",
			"i64 dot(Point a, Point b) {",
			"    return a.x * b.x + a.y * b.y;",
			"}",
			"",
			"i64 cross(Point a, Point b) {",
			"    return a.x * b.y - a.y * b.x;",
			"}",
			"",
			"Point operator+(Point a, Point b) {",
			"    return Point(a.x + b.x, a.y + b.y);",
			"}",
			"",
			"Point operator-(Point a, Point b) {",
			"    return Point(a.x - b.x, a.y - b.y);",
			"}",
			"",
			"auto getHull(std::vector<Point> p) {",
			"    std::sort(p.begin(), p.end(),",
			"        [&](auto a, auto b) {",
			"            return a.x < b.x || (a.x == b.x && a.y < b.y);",
			"        });",
			"    ",
			"    std::vector<Point> hi, lo;",
			"    for (auto p : p) {",
			"        while (hi.size() > 1 && cross(hi.back() - hi[hi.size() - 2], p - hi.back()) >= 0) {",
			"            hi.pop_back();",
			"        }",
			"        while (!hi.empty() && hi.back().x == p.x) {",
			"            hi.pop_back();",
			"        }",
			"        hi.push_back(p);",
			"        while (lo.size() > 1 && cross(lo.back() - lo[lo.size() - 2], p - lo.back()) <= 0) {",
			"            lo.pop_back();",
			"        }",
			"        if (lo.empty() || lo.back().x < p.x) {",
			"            lo.push_back(p);",
			"        }",
			"    }",
			"    return std::make_pair(hi, lo);",
			"}",
			"",
			"const double inf = INFINITY;"
		]
	}
}
